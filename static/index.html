<!DOCTYPE html>
<html>
<head>
  <meta name="viewport" content="width=device-width, user-scalable=no">
  <style>

    #recreation {
      width: 300px;
      height: 300px;
      position: relative;
    }

    .link {
      background-color: rgba(255,0,0,0.1);
      z-index: 9999;
      pointer-events: none;
      position: absolute;
      border: 0.5px solid rgba(255,0,0,0.4);
      border-radius: 3px;
    }

    .t {
      transform-origin: 0px 0px 0px;
      position: absolute;
    }

    .scroll {
      overflow: scroll;
    }
    
    ::-webkit-scrollbar {
      display: none;
    }

  </style>
  <script type="text/javascript">

    // ***************   Settings
    // These values are used to allow this to either be hosted as a static file or replaced by a
    // server-side script to eliminate a server round-trip.

    let options = {
      // Websocket for server comms.  Method to select websocket:
      //  * If available, connect to websocketServer.
      //  * Otherwise, if available, connect to websocketPool.
      //  * Otherwise, connect to document.location.host

      //websocketServer: 'wss://server.example.com/',
      //websocketServer: 'ws://localhost:12159',
    
      // It's a dns based pool with a custom load balancing algorithm.
      // servers are expected to register at n.serverpool.com, where n is an integer from 0 to ~ the pool
      // size.  A few gaps doesn't matter.  If servers with low numbers get inundated with load-discovery-requests,
      // take them down (should only happen >10k servers).
      // The client will connect to 10 hosts logarithmicly spaced, 
      // and use whichever has the lowest published load scaled by response time.
      // fastbrowser.omattos.com is provided without any SLA.  Expect to be blocked if you apply too much load.
      //websocketPool: 'fastbrowser.omattos.com',

      // Initial page to render
      startPage: "https://www.wikipedia.org/",

      // Options set dynamically by the server
      // %SERVEROPTIONS%
    }

    // Implements the chrome devtools protocol on top of a websocket.
    class devToolsWebsocket extends WebSocket {
      constructor(host){
        super(host + '/devtools/browser');
        this.nextid=0;
        this.callbacks = [];
        this.eventListeners = [];
        this.addEventListener('message', (evt) => {
          var d = JSON.parse(evt.data);
          if (this.callbacks[d.id]) {
            if (d.result)
              this.callbacks[d.id].resolve(d.result);
            else
              this.callbacks[d.id].reject(d.error);
            delete this.callbacks[d.id];
          } else
          if (this.eventListeners[d.method])
            this.eventListeners[d.method].forEach(x => x(d.params))
          else console.log("unknown msg",d);
        });
      }
      req = (method, params) => {
        return new Promise((resolve, reject) => {
          this.send(JSON.stringify({
            id: this.nextid,
            method,
            params,
            sessionId: this.sessionId,
          }));
          this.callbacks[this.nextid] = {resolve, reject}
          this.nextid++;
        });
      }
      setSessionId = (s) => {this.sessionId = s;}
    }

    // Implements a stochastic client-side loadbalancer
    function selectWebsocket(options) {
      return new Promise(function(resolve, reject) {
        let socketPool = [];
        if (options.websocketServer) {
          socketPool.push({id: 0, ws: new devToolsWebsocket(options.websocketServer)});
        } else if (options.websocketPool) {
          socketPool = socketPool.concat([...Array(10).keys()]
              .map(x => Math.floor(Math.random()*Math.pow(4,x)))
              .map(x => { return {id: x, ws: new devToolsWebsocket('wss://' + x + '.' + options.websocketPool)}})
            );
        } else {
          socketPool.push({id: 0, ws: new devToolsWebsocket(document.location.origin.replace('http', 'ws'))});
        }
        socketPool.doneCount = 0;
        socketPool.highestOpen = -1;

        function checkDone() {
          if (socketPool.resolved) return;
          if ((socketPool.doneCount/socketPool.length >= 0.9 && socketPool.highestOpen>=0)
              || socketPool.doneCount==socketPool.length ) {
            let goodSocketPool = socketPool.filter(x => x.load);
            goodSocketPool.sort((a,b) => a.load - b.load);

            socketPool.resolved = true;
            // TODO:  Should skip first few here due to log sampling.
            var selected = (goodSocketPool.length!=0)?goodSocketPool[0].ws:null;
            if (selected) resolve(selected)
            else reject(socketPool.lasterr);
            socketPool.forEach(x => (x.ws!=selected) && x.ws.close());
          }
        }
        socketPool.forEach(s => {
          s.ws.onopen = async () => {
            try {
              s.load = socketPool.length==1?1:(await s.ws.req('Load.GetLoad', {}));
            } catch {
              s.load = 1;
            };
            socketPool.doneCount++;
            socketPool.highestOpen = Math.max(socketPool.highestOpen, s.id);
            checkDone();
          };
          s.ws.onerror = (err) => {socketPool.doneCount++; socketPool.lasterr=err; checkDone()};
        });
      });
    }

    // get the websocket loading early in the page load.
    let wsPromise = selectWebsocket(options);

    function currentURL() {
      if (document.location.pathname.startsWith('/http')) {
        return document.location.pathname.substring(1)+document.location.search+document.location.hash;
      }
      return document.location.href;
    }

    function decodeLayerInfo(l) {
      var decoded = l.split('\n').map(x => x.split(':')).filter(x=>x.length>1).reduce((m, i) => (m[i[0].trim()] = i[1].trim(), m), {});

      res = {layerId: decoded.layer_id};
      res.drawsContent = decoded.Bounds != '0x0';

      res.name = decoded.name;
      res.bounds = decoded.Bounds.split('x').map(x => parseInt(x));
      res.offsetToTransformParent = decoded.OffsetToTransformParent.split(' ').map(x => parseFloat(x.replace(/[^\d.-]/g, '')));
      res.clip_tree_index = parseInt(decoded.clip_tree_index);
      res.effect_tree_index = parseInt(decoded.effect_tree_index);
      res.scroll_tree_index = parseInt(decoded.scroll_tree_index);
      res.transform_tree_index = parseInt(decoded.transform_tree_index);
      return res
    }

    function createDOMTransformNode(t, zIndex, adopt) {
      if (t.parent_id) {
        if (!t.dom && adopt)
          // See if there is an element we might adopt
          if (adopt.adoptable) {
            t.dom = adopt
          }
        createDOMTransformNode(t.parent_id, zIndex, t.dom && t.dom.parentNode);

        if (!t.dom) {
          t.dom = document.createElement('div');
          t.parent_id.dom.appendChild(t.dom);
        }
        t.dom.adoptable = false;
        
        if (t.dom.parentNode != t.parent_id.dom) {
          t.parent_id.dom.appendChild(t.dom);
        }
        t.dom.className = 't';
        t.dom.setAttribute('t'+t.id, '');
        alldata.proptrees.clip_tree.nodes.filter(x => x.transform_id === t).forEach(x => t.dom.setAttribute('c' + x.id, ''));
        alldata.proptrees.scroll_tree.nodes.filter(x => x.transform_id === t).forEach(x => t.dom.setAttribute('s' + x.id, ''));
        t.dom.style.zIndex = t.dom.style.zIndex?Math.max(zIndex, t.dom.style.zIndex):zIndex;

        if (t.clip) {
          t.dom.style.width = t.clip.clip[2] + 'px';
          t.dom.style.height = t.clip.clip[3] + 'px';
          t.dom.style.top = t.clip.clip[1] + 'px';
          t.dom.style.left = t.clip.clip[0] + 'px';
          if (t.clip.clip[0] || t.clip.clip[1])
            t.dom.style.transform = `matrix3d(1,0,0,0, 0,1,0,0, 0,0,1,0, ${t.clip.clip[0]},${t.clip.clip[1]},0,1) ` + toCss(t.local);
          else
            t.dom.style.transform = toCss(t.local);
        } else t.dom.style.transform = toCss(t.local);
        
        if (t.scroll) {
          t.dom.className = 't scroll';
          if (alldata.preventscrollElem != t.scroll.element_id.id_) {
            t.dom.scrollTop = t.scroll_offset[1];
            t.dom.scrollLeft = t.scroll_offset[0];
          }
          t.dom.onscroll = function() {
            //if (t.dom.scrollTop == t.scroll_offset[1] && t.dom.scrollLeft==t.scroll_offset[0]) return;
            alldata.preventscroll++;
            alldata.preventscrollElem = t.scroll.element_id.id_;
            socket.req('PageStream.setScroll', {backendNodeId:  t.scroll.element_id.id_, x: Math.floor(t.dom.scrollLeft), y: Math.floor(t.dom.scrollTop)}).then(x => {alldata.preventscroll--;});
          }
        }   

      } else {
        // Root transform is recreation
        t.dom = document.getElementById('recreation');
      }
    }
    function createDOMLayerNode(l) {

      if (!l.images || l.name == 'Frame Overlay Content Layer') return;

      // Huh - looks like a scrollingcontents layer.  If so, set everything up appropriately
      if (l.clip_tree_index.transform_id === l.scroll_tree_index.transform_id.parent_id  &&
          l.scroll_tree_index.scrollable) {
        l.scroll_tree_index.transform_id.scroll = l.scroll_tree_index;
        l.scroll_tree_index.transform_id.clip = l.clip_tree_index;
        
        createDOMTransformNode(l.scroll_tree_index.transform_id, 0, l.scrolldom);
        l.scrolldom = l.scroll_tree_index.transform_id.dom;
      }

      createDOMTransformNode(l.transform_tree_index, l.zIndex, l.dom && l.dom.parentNode);
            
      if (!l.dom) {
        l.dom=document.createElement('div');  // layer
      }
      if (l.dom.parentNode != l.transform_tree_index.dom) {
        // Transforms have changed - we need to add/move our layer elsewhere.
        l.transform_tree_index.dom.appendChild(l.dom);
      }
      
      l.images && l.images.forEach(i => {
        if (!i.dom) {
          i.dom = document.createElement('img');
          l.dom.appendChild(i.dom);
          i.dom.src=i.image;
          i.dom.style.position = 'absolute';
          i.dom.style.top = i.clip.y + 'px';
          i.dom.style.left = i.clip.x + 'px';
        }
      });

      l.dom.style.top = l.offsetToTransformParent[1] + 'px';
      l.dom.style.left = l.offsetToTransformParent[0]+ 'px';
      l.dom.width=l.bounds[0];
      l.dom.height=l.bounds[1];
      l.dom.style.position = 'absolute';
      l.dom.style.zIndex = l.zIndex;
      l.dom.setAttribute('l'+l.layerId, l.name);
      //l.dom.alt = l.name;
      //l.dom.l = l;

      l.targets && l.targets.forEach(t => {
        createTargetNode(t, l);
      });

    }

    function createTargetNode(t, l) {
      var container = l.dom.parentNode;
      if (!t.dom) t.dom=document.createElement('div')
      if (t.dom.parentNode != container) container.appendChild(t.dom);
      t.dom.style.left = t.containingQuads[0][0]+l.offsetToTransformParent[0]+'px';
      t.dom.style.top = t.containingQuads[0][1]+l.offsetToTransformParent[1]+'px';
      t.dom.style.width = (t.containingQuads[0][4]-t.containingQuads[0][0])+'px';
      t.dom.style.height = (t.containingQuads[0][5]-t.containingQuads[0][1])+'px';
      t.dom.className = 'link';
    }

    function toCss(matrix) {
      var matrix = Array(16).fill().reverse().map((_,i) => matrix[Math.floor(i/4) + (i%4)*4]);
      var res = 'matrix3d('+ matrix.join(',') + ')';
      // Special case identity transform
      if (res=="matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)") return '';
      return res;
    }

    var alldata = {preventscroll: 0, nextLayerUpdates: []};

    var layerDB = [];
    var makeTrees = () => {
      var clip_tree = alldata.proptrees.clip_tree.nodes.reduce((map, obj) => (map[obj.id] = obj, map), []);
      var effect_tree = alldata.proptrees.effect_tree.nodes.reduce((map, obj) => (map[obj.id] = obj, map), []);
      var scroll_tree = alldata.proptrees.scroll_tree.nodes.reduce((map, obj) => (map[obj.id] = obj, map), []);
      var transform_tree = alldata.proptrees.transform_tree.nodes.reduce((map, obj) => (map[obj.id] = obj, map), []);

      var layer_tree = layerDB;

      function get_tree_node(a) {
        if (Number.isInteger(a) || a === undefined) return a;
        return a.id;
      }
      layer_tree.forEach(l => {
        l.clip_tree_index = clip_tree[get_tree_node(l.clip_tree_index)];
        l.effect_tree_index = effect_tree[get_tree_node(l.effect_tree_index)];
        l.scroll_tree_index = scroll_tree[get_tree_node(l.scroll_tree_index)];
        l.transform_tree_index = transform_tree[get_tree_node(l.transform_tree_index)];
      });
      transform_tree.forEach(l => {
        l.parent_id = transform_tree[get_tree_node(l.parent_id)];
      });
      scroll_tree.forEach(l => {
        l.parent_id = scroll_tree[get_tree_node(l.parent_id)];
        l.transform_id = transform_tree[get_tree_node(l.transform_id)];
      });
      effect_tree.forEach(l => {
        l.parent_id = effect_tree[get_tree_node(l.parent_id)];
        l.transform_id = transform_tree[get_tree_node(l.transform_id)];
        l.clip_id = clip_tree[get_tree_node(l.clip_id)];
      });
      clip_tree.forEach(l => {
        l.parent_id = clip_tree[get_tree_node(l.parent_id)];
        l.transform_id = transform_tree[get_tree_node(l.transform_id)];
      });
      
      alldata = {...alldata, clip_tree, effect_tree, scroll_tree, transform_tree, layer_tree};

    }
    var updateScreen = () => {

      // apply proptrees
      alldata.proptrees = alldata.nextProptrees;

      // apply layerupdates
      alldata.nextLayerUpdates.forEach(params => {
        var l = layerDB[params.layerId] = layerDB[params.layerId] || {};

        if (params.layerDeleted) {
          l.dom && l.dom.remove();
          l.targets && l.targets.forEach(t => t.dom && t.dom.remove()); 
          delete layerDB[params.layerId];
          return;
        }

        if (params.layerInfo) {
          layerDB[params.layerId] = l = {...l, ...decodeLayerInfo(params.layerInfo)};
        }

        if (params.zIndex)
          l.zIndex=params.zIndex;

        if (params.image) {
          l.images = l.images || [];

          // Cull images this new image covers up (note - this test could cull more things)
          for (let i = l.images.length - 1; i >= 0; i--) {
            if (l.images[i].clip.x >= params.clip.x &&
              l.images[i].clip.y >= params.clip.y &&
              l.images[i].clip.x + l.images[i].clip.width <= params.clip.x + params.clip.width &&
              l.images[i].clip.y + l.images[i].clip.height <= params.clip.y + params.clip.height) {
            l.images[i].dom && l.images[i].dom.remove();
            l.images.splice(i, 1);
            }
          }
          l.images.push({image: params.image, clip: params.clip });
        }

        if (params.targets) {
          l.targets && l.targets.forEach(t => {
            if (t.dom) {  // Adopt old element if possible
              var res = params.targets.filter(y => y.backendNodeId==t.backendNodeId)[0];
              if (res) res.dom = t.dom;
              else t.dom.remove();
            }
          });

          l.targets=params.targets;
        }
      });

      alldata.nextLayerUpdates = [];

      // Mark all transform nodes as adoptable and set them back to no zindex
      var old_transform_tree = alldata.transform_tree;
      if (old_transform_tree) old_transform_tree.forEach(t => {
        if (t.dom && t.parent_id) {
          t.dom.style.zIndex=0;
          t.dom.adoptable=true
        }

      });

      makeTrees();

      
      layerDB.forEach(l => {
        createDOMLayerNode(l);
      });

      // remove unowned transform nodes
      if (old_transform_tree) old_transform_tree.forEach(t => {
        if (t.dom && (t.dom.adoptable==true))
          t.dom.remove();
      });
    };
    
    window.addEventListener('DOMContentLoaded', async (event) => {
      // 
      socket = await wsPromise;

      window.socket = socket;  // for testing

      // All these are run serially on startup, but none depend on a
      // response from a request.  The intention is a server can fire
      // off all these requests to the browser before the client even
      // connects to speed up initial loading.
      socket.req('Target.setDiscoverTargets', {discover: true});
      socket.eventListeners['Target.targetCreated'] = [ msg => {
        if (msg.targetInfo.type=='page') {
          socket.req('Target.attachToTarget', {targetId: msg.targetInfo.targetId, flatten: true});
        }
      }];
      socket.eventListeners['Target.attachedToTarget'] = [ msg => {
        // TODO:  Handle case of multiple targets/sessions/windows etc.
        console.log("new target", msg);
        socket.setSessionId(msg.sessionId)
        socket.req('Page.navigate', {url: currentURL()});
        socket.req('Page.enable');
        socket.req('PageStream.enable');

        resize();      
      }]

      socket.eventListeners['PageStream.streamLayerInfo'] = [ msg => {
        alldata.nextLayerUpdates = alldata.nextLayerUpdates || [];
        alldata.nextLayerUpdates.push(msg.layerUpdate);
      }];

      socket.eventListeners['PageStream.streamPropTrees'] = [ params => {
        alldata.nextProptrees = JSON.parse(params.propertyTreesJSON);
      }];
      
      socket.eventListeners['PageStream.frameDone'] = [ () => {
        updateScreen();
      }];

      socket.eventListeners['Target.targetInfoChanged'] = [ params => {
        // Update URL and page title
        if (params.targetInfo.url.startsWith('http'))
          if (currentURL() != params.targetInfo.url)
            history.pushState({}, "test", '/'+params.targetInfo.url);
        // This doesn't work properly because the browser doesn't emit an event if
        // the title changes without a navigation event happening.
        document.title = params.targetInfo.title;
      }];

      var resize = () => {
        socket.req('Emulation.setDeviceMetricsOverride', {
          height: document.documentElement.clientHeight,
          width: document.documentElement.clientWidth,
          deviceScaleFactor: window.devicePixelRatio,
          mobile: true
        })
      }
      window.addEventListener('resize', resize);
      
      var touch = (n, e) => {
        socket.req('Input.dispatchTouchEvent', {
          type: n,
          touchPoints: Array(...e.touches).map(t => { return {x: t.clientX, y: t.clientY, id:t.identifier}}),
        });
      };
      document.body.addEventListener('touchstart', touch.bind(null, 'touchStart'), {passive: true});
      document.body.addEventListener('touchend', touch.bind(null, 'touchEnd'), {passive: true});
      document.body.addEventListener('touchcancel', touch.bind(null, 'touchCancel'), {passive: true});
      document.body.addEventListener('touchmove', touch.bind(null, 'touchMove'), {passive: true});
    });

  </script>
</head>
<body style='margin:0px'>
  <div id='recreation'></div>
</body>
</html>
