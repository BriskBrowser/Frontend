<!DOCTYPE html>
<html>
<head>
  <meta name="viewport" content="width=device-width, user-scalable=no">
  <style>

    bb-session {
      width: 300px;
      height: 200px;
      position: relative;
      display: block;
    }

    .link {
      background-color: rgba(255,0,0,0.1);
      z-index: 9999;
      cursor: pointer;
      position: absolute;
      border: 0.5px solid rgba(255,0,0,0.4);
      border-radius: 3px;
    }

    .t {
      transform-origin: 0px 0px 0px;
      position: absolute;
    }

    .scroll {
      overflow: scroll;
    }
    
    ::-webkit-scrollbar {
      display: none;
    }

  </style>
  <script type="text/javascript">

    // ***************   Settings
    // These values are used to allow this to either be hosted as a static file or replaced by a
    // server-side script to eliminate a server round-trip.

    let options = {
      // Websocket for server comms.  Method to select websocket:
      //  * If available, connect to websocketServer.
      //  * Otherwise, if available, connect to websocketPool.
      //  * Otherwise, connect to document.location.host

      //websocketServer: 'wss://server.example.com/',
      //websocketServer: 'ws://localhost:12159',
    
      // It's a dns based pool with a custom load balancing algorithm.
      // servers are expected to register at n.serverpool.com, where n is an integer from 0 to ~ the pool
      // size.  A few gaps doesn't matter.  If servers with low numbers get inundated with load-discovery-requests,
      // take them down (should only happen >10k servers).
      // The client will connect to 10 hosts logarithmicly spaced, 
      // and use whichever has the lowest published load scaled by response time.
      // fastbrowser.omattos.com is provided without any SLA.  Expect to be blocked if you apply too much load.
      //websocketPool: 'fastbrowser.omattos.com',

      // Initial page to render
      startPage: "https://www.wikipedia.org/",

      // Options set dynamically by the server
      // %SERVEROPTIONS%
    }

    // Implements the chrome devtools protocol on top of a websocket.
    class devToolsWebsocket extends WebSocket {
      constructor(host){
        super(host + '/devtools/browser');
        this.nextid=0;
        this.callbacks = [];
        this.eventListeners = [];
        this.childSockets = [];
        this.addEventListener('message', (evt) => {
          var d = JSON.parse(evt.data);
          if (this.callbacks[d.id]) {
            if (d.result)
              this.callbacks[d.id].resolve(d.result);
            else
              this.callbacks[d.id].reject(d.error);
            delete this.callbacks[d.id];
          } else
          if (this.eventListeners[d.method])
            this.eventListeners[d.method](d.params)
          this.childSockets.forEach(x=>x.handleMessage(d));
        });
      }
      req = (sessionId, method, params) => {
        return new Promise((resolve, reject) => {
          this.send(JSON.stringify({
            id: this.nextid,
            method,
            params,
            sessionId,
          }));
          this.callbacks[this.nextid] = {resolve, reject}
          this.nextid++;
        });
      }
    }

    class devToolsWebsocketWrapper {
      constructor (wrappedSocket, sessionId) {
        this.wrappedSocket = wrappedSocket;
        this.sessionId = sessionId;
        this.eventListeners = [];
        this.wrappedSocket.childSockets.push(this);
      }
      req = (method, params) => {
        return this.wrappedSocket.req(this.sessionId, method, params);
      }
      handleMessage = (msg) => {
        if (msg.sessionId == this.sessionId  && this.eventListeners[msg.method])
            this.eventListeners[msg.method](msg.params);
      }
      destroy = () => {
        this.wrappedSocket.childSockets = this.wrappedSocket.childSockets.filter(x=> x != this);
      }
    }

    // Implements a stochastic client-side loadbalancer
    function selectWebsocket(options) {
      return new Promise(function(resolve, reject) {
        let socketPool = [];
        if (options.websocketServer) {
          socketPool.push({id: 0, ws: new devToolsWebsocket(options.websocketServer)});
        } else if (options.websocketPool) {
          socketPool = socketPool.concat([...Array(10).keys()]
              .map(x => Math.floor(Math.random()*Math.pow(4,x)))
              .map(x => { return {id: x, ws: new devToolsWebsocket('wss://' + x + '.' + options.websocketPool)}})
            );
        } else {
          socketPool.push({id: 0, ws: new devToolsWebsocket(document.location.origin.replace('http', 'ws'))});
        }
        socketPool.doneCount = 0;
        socketPool.highestOpen = -1;

        function checkDone() {
          if (socketPool.resolved) return;
          if ((socketPool.doneCount/socketPool.length >= 0.9 && socketPool.highestOpen>=0)
              || socketPool.doneCount==socketPool.length ) {
            let goodSocketPool = socketPool.filter(x => x.load);
            goodSocketPool.sort((a,b) => a.load - b.load);

            socketPool.resolved = true;
            // TODO:  Should skip first few here due to log sampling.
            var selected = (goodSocketPool.length!=0)?goodSocketPool[0].ws:null;
            if (selected) resolve(selected)
            else reject(socketPool.lasterr);
            socketPool.forEach(x => (x.ws!=selected) && x.ws.close());
          }
        }
        socketPool.forEach(s => {
          s.ws.onopen = async () => {
            try {
              s.load = socketPool.length==1?1:(await s.ws.req(undefined, 'Load.GetLoad', {}));
            } catch {
              s.load = 1;
            };
            socketPool.doneCount++;
            socketPool.highestOpen = Math.max(socketPool.highestOpen, s.id);
            checkDone();
          };
          s.ws.onerror = (err) => {socketPool.doneCount++; socketPool.lasterr=err; checkDone()};
        });
      });
    }

    // get the websocket loading early in the page load.
    let wsPromise = selectWebsocket(options);

    function currentURL() {
      if (document.location.pathname.startsWith('/http')) {
        return document.location.pathname.substring(1)+document.location.search+document.location.hash;
      }
      return document.location.href;
    }

    function deepClone(obj, hash = new WeakMap()) {
        // Do not try to clone primitives or functions
        if (Object(obj) !== obj) return obj;
        if (obj instanceof Function || obj instanceof HTMLElement)
          return undefined;
        if (hash.has(obj)) return hash.get(obj); // Cyclic reference
        var result = new obj.constructor();
        // Register in hash    
        hash.set(obj, result);
        // Clone and assign enumerable own properties recursively
        return Object.assign(result, ...Object.keys(obj).map (
            key => ({ [key]: deepClone(obj[key], hash) }) ));
    }

    class Session {
      constructor(ws, domElement, baseSession) {
        this.sessionState = {preventscroll: 0, nextLayerUpdates: [], layer_tree: []};

        this.ws = ws;
        this.domElement = domElement;
        this.onNewSession = () => {};

        if (baseSession) {
          this.sessionState = deepClone(baseSession.sessionState);

          // Create dom nodes for everything.
          this.sessionState.layer_tree.forEach(l => {
            this.createDOMLayerNode(l);
          });
        }

        this.ws.eventListeners['PageStream.streamLayerInfo'] =  msg => {
          this.sessionState.nextLayerUpdates.push(msg.layerUpdate);
          // Create any sessions for event target clicks, because they could start sending data right away.
          msg.layerUpdate.targets && msg.layerUpdate.targets.forEach(x=>x.sessionId && this.onNewSession(ws.wrappedSocket, x.sessionId, this));
        };

        this.ws.eventListeners['PageStream.streamPropTrees'] =  params => {
          this.sessionState.nextProptrees = JSON.parse(params.propertyTreesJSON);
        };
        
        this.ws.eventListeners['PageStream.frameDone'] = () => {
          this.updateScreen();
        };

        ['touchStart', 'touchEnd', 'touchCancel', 'touchMove'].forEach(evt =>
          this.domElement.addEventListener(evt.toLowerCase(), this.touch.bind(this, evt), {passive: true}));

      }

      decodeLayerInfo(l) {
        var decoded = l.split('\n').map(x => x.split(':')).filter(x=>x.length>1).reduce((m, i) => (m[i[0].trim()] = i[1].trim(), m), {});

        var res = {layerId: decoded.layer_id};
        res.drawsContent = decoded.Bounds != '0x0';

        res.name = decoded.name;
        res.bounds = decoded.Bounds.split('x').map(x => parseInt(x));
        res.offsetToTransformParent = decoded.OffsetToTransformParent.split(' ').map(x => parseFloat(x.replace(/[^\d.-]/g, '')));
        res.clip_tree_index = parseInt(decoded.clip_tree_index);
        res.effect_tree_index = parseInt(decoded.effect_tree_index);
        res.scroll_tree_index = parseInt(decoded.scroll_tree_index);
        res.transform_tree_index = parseInt(decoded.transform_tree_index);
        return res
      }

      createDOMTransformNode(t, zIndex, adopt) {
        if (t.parent_id) {
          if (!t.dom && adopt)
            // See if there is an element we might adopt
            if (adopt.adoptable) {
              t.dom = adopt
            }
          this.createDOMTransformNode(t.parent_id, zIndex, t.dom && t.dom.parentNode);

          if (!t.dom) {
            t.dom = document.createElement('div');
            t.parent_id.dom.appendChild(t.dom);
          }
          t.dom.adoptable = false;
          
          if (t.dom.parentNode != t.parent_id.dom) {
            t.parent_id.dom.appendChild(t.dom);
          }
          t.dom.className = 't';
          t.dom.setAttribute('t'+t.id, '');
          //this.sessionState.proptrees.clip_tree.nodes.filter(x => x.transform_id === t).forEach(x => t.dom.setAttribute('c' + x.id, ''));
          //this.sessionState.proptrees.scroll_tree.nodes.filter(x => x.transform_id === t).forEach(x => t.dom.setAttribute('s' + x.id, ''));
          t.dom.style.zIndex = t.dom.style.zIndex?Math.max(zIndex, t.dom.style.zIndex):zIndex;

          if (t.clip) {
            t.dom.style.width = t.clip.clip[2] + 'px';
            t.dom.style.height = t.clip.clip[3] + 'px';
            t.dom.style.top = t.clip.clip[1] + 'px';
            t.dom.style.left = t.clip.clip[0] + 'px';
            if (t.clip.clip[0] || t.clip.clip[1])
              t.dom.style.transform = `matrix3d(1,0,0,0, 0,1,0,0, 0,0,1,0, ${t.clip.clip[0]},${t.clip.clip[1]},0,1) ` + this.toCss(t.local);
            else
              t.dom.style.transform = this.toCss(t.local);
          } else t.dom.style.transform = this.toCss(t.local);
          
          if (t.scroll) {
            t.dom.className = 't scroll';
            if (this.sessionState.preventscrollElem != t.scroll.element_id.id_) {
              t.dom.scrollTop = t.scroll_offset[1];
              t.dom.scrollLeft = t.scroll_offset[0];
            }
            t.dom.onscroll = this.scrollHandler.bind(this, t);
          }   

        } else {
          // Root transform is the one given when the class was constructed
          t.dom = this.domElement
        }
      }

      scrollHandler(t, evt) {
        this.sessionState.preventscroll++;
        this.sessionState.preventscrollElem = t.scroll.element_id.id_;
        //if (t.dom.scrollTop == t.scroll_offset[1] && t.dom.scrollLeft==t.scroll_offset[0]) return;
        this.ws.req('PageStream.setScroll', {backendNodeId:  t.scroll.element_id.id_, x: Math.floor(t.dom.scrollLeft), y: Math.floor(t.dom.scrollTop)}).then(x => {this.sessionState.preventscroll--;});
      }
      createDOMLayerNode(l) {

        if (!l.images || l.name == 'Frame Overlay Content Layer') return;

        // Huh - looks like a scrollingcontents layer.  If so, set everything up appropriately
        if (l.clip_tree_index.transform_id === l.scroll_tree_index.transform_id.parent_id  &&
            l.scroll_tree_index.scrollable) {
          l.scroll_tree_index.transform_id.scroll = l.scroll_tree_index;
          l.scroll_tree_index.transform_id.clip = l.clip_tree_index;
          
          this.createDOMTransformNode(l.scroll_tree_index.transform_id, 0, l.scrolldom);
          l.scrolldom = l.scroll_tree_index.transform_id.dom;
        }

        this.createDOMTransformNode(l.transform_tree_index, l.zIndex, l.dom && l.dom.parentNode);
              
        if (!l.dom) {
          l.dom=document.createElement('div');  // layer
        }
        if (l.dom.parentNode != l.transform_tree_index.dom) {
          // Transforms have changed - we need to add/move our layer elsewhere.
          l.transform_tree_index.dom.appendChild(l.dom);
        }
        
        l.images && l.images.forEach(i => {
          if (!i.dom) {
            i.dom = document.createElement('img');
            l.dom.appendChild(i.dom);
            i.dom.src=i.image;
            i.dom.style.position = 'absolute';
            i.dom.style.top = i.clip.y + 'px';
            i.dom.style.left = i.clip.x + 'px';
          }
        });

        l.dom.style.top = l.offsetToTransformParent[1] + 'px';
        l.dom.style.left = l.offsetToTransformParent[0]+ 'px';
        l.dom.width=l.bounds[0];
        l.dom.height=l.bounds[1];
        l.dom.style.position = 'absolute';
        l.dom.style.zIndex = l.zIndex;
        l.dom.setAttribute('l'+l.layerId, l.name);
        //l.dom.alt = l.name;
        //l.dom.l = l;

        l.targets && l.targets.forEach(t => {
          this.createTargetNode(t, l);
        });

      }

      targetClick(evt) {
        this.ws.req('PageStream.clickNode', { backendNodeId: evt.currentTarget.metadata.backendNodeId } );
        evt.stopPropagation();
      }

      createTargetNode(t, l) {
        var container = l.dom.parentNode;
        if (!t.dom) t.dom=document.createElement('div')
        if (t.dom.parentNode != container) container.appendChild(t.dom);
        t.dom.style.left = t.containingQuads[0][0]+l.offsetToTransformParent[0]+'px';
        t.dom.style.top = t.containingQuads[0][1]+l.offsetToTransformParent[1]+'px';
        t.dom.style.width = (t.containingQuads[0][4]-t.containingQuads[0][0])+'px';
        t.dom.style.height = (t.containingQuads[0][5]-t.containingQuads[0][1])+'px';
        t.dom.onclick = this.targetClick.bind(this);
        t.dom.metadata = t;
        t.dom.className = 'link';
      }

      toCss(matrix) {
        var matrix = Array(16).fill().reverse().map((_,i) => matrix[Math.floor(i/4) + (i%4)*4]);
        var res = 'matrix3d('+ matrix.join(',') + ')';
        // Special case identity transform
        if (res=="matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)") return '';
        return res;
      }


      makeTrees(propTrees) {
        var clip_tree = propTrees.clip_tree.nodes.reduce((map, obj) => (map[obj.id] = obj, map), []);
        var effect_tree = propTrees.effect_tree.nodes.reduce((map, obj) => (map[obj.id] = obj, map), []);
        var scroll_tree = propTrees.scroll_tree.nodes.reduce((map, obj) => (map[obj.id] = obj, map), []);
        var transform_tree = propTrees.transform_tree.nodes.reduce((map, obj) => (map[obj.id] = obj, map), []);

        var layer_tree = this.sessionState.layer_tree;

        function get_tree_node(a) {
          if (Number.isInteger(a) || a === undefined) return a;
          return a.id;
        }
        layer_tree.forEach(l => {
          l.clip_tree_index = clip_tree[get_tree_node(l.clip_tree_index)];
          l.effect_tree_index = effect_tree[get_tree_node(l.effect_tree_index)];
          l.scroll_tree_index = scroll_tree[get_tree_node(l.scroll_tree_index)];
          l.transform_tree_index = transform_tree[get_tree_node(l.transform_tree_index)];
        });
        transform_tree.forEach(l => {
          l.parent_id = transform_tree[get_tree_node(l.parent_id)];
        });
        scroll_tree.forEach(l => {
          l.parent_id = scroll_tree[get_tree_node(l.parent_id)];
          l.transform_id = transform_tree[get_tree_node(l.transform_id)];
        });
        effect_tree.forEach(l => {
          l.parent_id = effect_tree[get_tree_node(l.parent_id)];
          l.transform_id = transform_tree[get_tree_node(l.transform_id)];
          l.clip_id = clip_tree[get_tree_node(l.clip_id)];
        });
        clip_tree.forEach(l => {
          l.parent_id = clip_tree[get_tree_node(l.parent_id)];
          l.transform_id = transform_tree[get_tree_node(l.transform_id)];
        });
        
        this.sessionState = {...this.sessionState, clip_tree, effect_tree, scroll_tree, transform_tree, layer_tree};

      }
      updateScreen() {
        // apply layerupdates
        this.sessionState.nextLayerUpdates.forEach(params => {
          var l = this.sessionState.layer_tree[params.layerId] = this.sessionState.layer_tree[params.layerId] || {};

          if (params.layerDeleted) {
            l.dom && l.dom.remove();
            l.targets && l.targets.forEach(t => t.dom && t.dom.remove()); 
            delete this.sessionState.layer_tree[params.layerId];
            return;
          }

          if (params.layerInfo) {
            this.sessionState.layer_tree[params.layerId] = l = {...l, ...this.decodeLayerInfo(params.layerInfo)};
          }

          if (params.zIndex)
            l.zIndex=params.zIndex;

          if (params.image) {
            l.images = l.images || [];

            // Cull images this new image covers up (note - this test could cull more things)
            for (let i = l.images.length - 1; i >= 0; i--) {
              if (l.images[i].clip.x >= params.clip.x &&
                l.images[i].clip.y >= params.clip.y &&
                l.images[i].clip.x + l.images[i].clip.width <= params.clip.x + params.clip.width &&
                l.images[i].clip.y + l.images[i].clip.height <= params.clip.y + params.clip.height) {
              l.images[i].dom && l.images[i].dom.remove();
              l.images.splice(i, 1);
              }
            }
            l.images.push({image: params.image, clip: params.clip });
          }

          if (params.targets) {
            l.targets && l.targets.forEach(t => {
              if (t.dom) {  // Adopt old element if possible
                var res = params.targets.filter(y => y.backendNodeId==t.backendNodeId)[0];
                if (res) res.dom = t.dom;
                else t.dom.remove();
              }
            });

            l.targets=params.targets;
          }
        });

        this.sessionState.nextLayerUpdates = [];

        // Mark all transform nodes as adoptable and set them back to no zindex
        var old_transform_tree = this.sessionState.transform_tree;
        if (old_transform_tree) old_transform_tree.forEach(t => {
          if (t.dom && t.parent_id) {
            t.dom.style.zIndex=0;
            t.dom.adoptable=true
          }

        });

        // apply proptrees
        this.makeTrees(this.sessionState.nextProptrees);
        
        // Create or adopt all layers, (and by extension scrolls, clips, transforms and targets)
        this.sessionState.layer_tree.forEach(l => {
          this.createDOMLayerNode(l);
        });

        // remove unowned transform nodes
        if (old_transform_tree) old_transform_tree.forEach(t => {
          if (t.dom && (t.dom.adoptable==true))
            t.dom.remove();
        });
      }

      resize() {
        this.ws.req('Emulation.setDeviceMetricsOverride', {
          height: this.domElement.offsetHeight,
          width: this.domElement.offsetWidth,
          deviceScaleFactor: window.devicePixelRatio,
          mobile: true
        }); 
      }

      touch(n, e){
        this.ws.req('Input.dispatchTouchEvent', {
          type: n,
          touchPoints: Array(...e.touches).map(t => { return {x: t.clientX, y: t.clientY, id:t.identifier}}),
        });
      }
    }
        
    window.addEventListener('DOMContentLoaded', async (event) => {
      
      socket = await wsPromise;

      window.socket = socket;  // for testing

      var sessions = {};

      // All these are run serially on startup, but none depend on a
      // response from a request.  The intention is a server can fire
      // off all these requests to the browser before the client even
      // connects to speed up initial loading.
      socket.req(undefined, 'Target.setDiscoverTargets', {discover: true});
      socket.eventListeners['Target.targetCreated'] = msg => {
        if (msg.targetInfo.type=='page') {
          socket.req(undefined, 'Target.attachToTarget', {targetId: msg.targetInfo.targetId, flatten: true});
        }
      };

      function addSession(socket, sessionId, existingSession) {
        if (sessions[sessionId]) return;
        
        var newElem = document.createElement('bb-session');
        document.getElementById('recreation').appendChild(newElem);

        var ws = new devToolsWebsocketWrapper(socket, sessionId);
        
        var sess = new Session(ws, newElem, existingSession);
        sessions[sessionId] = sess;

        sess.onNewSession = addSession;
        return sess;
      }

      socket.eventListeners['Target.attachedToTarget'] = msg => {
        // TODO:  Handle case of multiple targets/sessions/windows etc.
        console.log("new target", msg);

        
        var sess = addSession(socket,  msg.sessionId, null);

        sess.ws.req('Page.navigate', {url: currentURL()});
        sess.ws.req('Page.enable');
        sess.ws.req('PageStream.enable');

        resize();     
      };


      socket.eventListeners['Target.targetInfoChanged'] = params => {
        // Update URL and page title
        if (params.targetInfo.url.startsWith('http'))
          if (currentURL() != params.targetInfo.url)
            history.pushState({}, "test", '/'+params.targetInfo.url);
        // This doesn't work properly because the browser doesn't emit an event if
        // the title changes without a navigation event happening.
        document.title = params.targetInfo.title;
      };

      var resize = () => {
        Object.values(sessions).forEach(x=> x.resize());
      }
      window.addEventListener('resize', resize);
      
    });

  </script>
  <script async src="https://securepubads.g.doubleclick.net/tag/js/gpt.js"></script>
  <script>
    window.googletag = window.googletag || {cmd: []};
    googletag.cmd.push(function() {
      googletag.defineSlot('/21912372412/test2', [[300, 50], [88, 31], [320, 100], [320, 50], 'fluid', [220, 90], [300, 31], [300, 75], [468, 60], [300, 100]], 'div-gpt-ad-1580941460580-0').addService(googletag.pubads());
      googletag.pubads().enableSingleRequest();
      googletag.enableServices();
    });
  </script>
</head>
<body style='margin:0px'>
  <div id='recreation'></div>
  <div id='div-gpt-ad-1580941460580-0'>
    <script>
      googletag.cmd.push(function() { googletag.display('div-gpt-ad-1580941460580-0'); });
    </script>
  </div>
  <a href="https://omattos.com/">See content</a>
</body>
</html>
